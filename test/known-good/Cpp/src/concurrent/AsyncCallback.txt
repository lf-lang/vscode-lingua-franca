<span class="source-lf comment-line-double-dash-lflang">// Test asynchronous callbacks that trigger a physical action.</span>
<span class="source-lf meta-targetspec-lflang keyword-control-lflang">target</span><span class="source-lf meta-targetspec-lflang"> </span><span class="source-lf meta-targetspec-lflang constant-language-lflang">Cpp</span><span class="source-lf meta-targetspec-lflang"> {</span>
<span class="source-lf meta-targetspec-lflang variable-parameter-lflang">    timeout</span><span class="source-lf meta-targetspec-lflang">: </span><span class="source-lf meta-targetspec-lflang constant-numeric-int-lflang">2</span><span class="source-lf meta-targetspec-lflang"> </span><span class="source-lf meta-targetspec-lflang constant-numeric-lflang">sec</span><span class="source-lf meta-targetspec-lflang">,</span>
<span class="source-lf meta-targetspec-lflang variable-parameter-lflang">    cmake-include</span><span class="source-lf meta-targetspec-lflang">: </span><span class="source-lf meta-targetspec-lflang string-quoted-double-lflang">"</span><span class="source-lf meta-targetspec-lflang string-quoted-double-lflang">AsyncCallback.cmake</span><span class="source-lf meta-targetspec-lflang string-quoted-double-lflang">"</span>
<span class="source-lf meta-targetspec-lflang">}</span>
<span class="source-lf"></span>
<span class="source-lf storage-modifier-lflang">main</span><span class="source-lf"> </span><span class="source-lf storage-modifier-lflang">reactor</span><span class="source-lf"> </span><span class="source-lf entity-name-type-lflang">AsyncCallback</span><span class="source-lf"> {</span>
<span class="source-lf">    </span><span class="source-lf keyword-control-lflang">public</span><span class="source-lf"> </span><span class="source-lf keyword-control-lflang">preamble</span><span class="source-lf"> {</span><span class="source-lf keyword-operator-lflang">=</span>
<span class="source-lf comment-line-double-dash-lflang">        </span><span class="source-lf comment-line-double-dash-lflang">#include <thread></span>
<span class="source-lf">    </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf">}</span>
<span class="source-lf"></span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">timer</span><span class="source-lf"> t(</span><span class="source-lf constant-numeric-int-lflang">0</span><span class="source-lf">, </span><span class="source-lf constant-numeric-int-lflang">200</span><span class="source-lf"> </span><span class="source-lf constant-numeric-lflang">msec</span><span class="source-lf">)</span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">state</span><span class="source-lf meta-embedded-block-cpp"> thread:</span><span class="source-lf meta-embedded-block-cpp"> </span><span class="source-lf">{</span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf variable-other-constant-reactorinstance-lflang">std</span><span class="source-lf keyword-operator-lflang">::</span><span class="source-lf variable-other-lflang">thread</span><span class="source-lf"> </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf">}</span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">state</span><span class="source-lf meta-embedded-block-cpp"> expected_time:</span><span class="source-lf meta-embedded-block-cpp storage-type-lflang"> time</span><span class="source-lf meta-embedded-block-cpp">(</span><span class="source-lf constant-numeric-int-lflang">100</span><span class="source-lf"> </span><span class="source-lf constant-numeric-lflang">msec</span><span class="source-lf">)</span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">state</span><span class="source-lf meta-embedded-block-cpp"> toggle:</span><span class="source-lf meta-embedded-block-cpp storage-type-lflang"> bool</span><span class="source-lf meta-embedded-block-cpp">(</span><span class="source-lf constant-language-lflang">false</span><span class="source-lf">)</span>
<span class="source-lf"></span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">physical</span><span class="source-lf"> </span><span class="source-lf storage-modifier-lflang">action</span><span class="source-lf meta-embedded-block-cpp"> a:</span><span class="source-lf meta-embedded-block-cpp storage-type-lflang"> int</span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">state</span><span class="source-lf meta-embedded-block-cpp"> i:</span><span class="source-lf meta-embedded-block-cpp storage-type-lflang"> int</span><span class="source-lf meta-embedded-block-cpp">(</span><span class="source-lf constant-numeric-int-lflang">0</span><span class="source-lf">)</span>
<span class="source-lf"></span>
<span class="source-lf">    </span><span class="source-lf keyword-control-lflang">reaction</span><span class="source-lf">(t) </span><span class="source-lf keyword-operator-lflang">-></span><span class="source-lf"> a {</span><span class="source-lf keyword-operator-lflang">=</span>
<span class="source-lf comment-line-double-dash-lflang">        </span><span class="source-lf comment-line-double-dash-lflang">// make sure to join the old thread first</span>
<span class="source-lf">        if(</span><span class="source-lf variable-other-constant-reactorinstance-lflang">thread</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">joinable</span><span class="source-lf">()) {</span>
<span class="source-lf">            </span><span class="source-lf variable-other-constant-reactorinstance-lflang">thread</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">join</span><span class="source-lf">();</span>
<span class="source-lf">        }</span>
<span class="source-lf"></span>
<span class="source-lf comment-line-double-dash-lflang">        </span><span class="source-lf comment-line-double-dash-lflang">// start new thread</span>
<span class="source-lf">        this</span><span class="source-lf keyword-operator-lflang">-></span><span class="source-lf">thread </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf variable-other-constant-reactorinstance-lflang">std</span><span class="source-lf keyword-operator-lflang">::</span><span class="source-lf variable-other-lflang">thread</span><span class="source-lf">([&] () {</span>
<span class="source-lf comment-line-double-dash-lflang">            </span><span class="source-lf comment-line-double-dash-lflang">// Simulate time passing before a callback occurs</span>
<span class="source-lf">            </span><span class="source-lf variable-other-constant-reactorinstance-lflang">std</span><span class="source-lf keyword-operator-lflang">::</span><span class="source-lf variable-other-constant-reactorinstance-lflang">this_thread</span><span class="source-lf keyword-operator-lflang">::</span><span class="source-lf variable-other-lflang">sleep_for</span><span class="source-lf">(100ms);</span>
<span class="source-lf comment-line-double-dash-lflang">            </span><span class="source-lf comment-line-double-dash-lflang">// Schedule twice. If the action is not physical, these should</span>
<span class="source-lf comment-line-double-dash-lflang">            </span><span class="source-lf comment-line-double-dash-lflang">// get consolidated into a single action triggering. If it is,</span>
<span class="source-lf comment-line-double-dash-lflang">            </span><span class="source-lf comment-line-double-dash-lflang">// then they cause two separate triggerings with close but not</span>
<span class="source-lf comment-line-double-dash-lflang">            </span><span class="source-lf comment-line-double-dash-lflang">// equal time stamps.</span>
<span class="source-lf">            </span><span class="source-lf variable-other-constant-reactorinstance-lflang">a</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">schedule</span><span class="source-lf">(</span><span class="source-lf constant-numeric-int-lflang">0</span><span class="source-lf">);</span>
<span class="source-lf">            </span><span class="source-lf variable-other-constant-reactorinstance-lflang">a</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">schedule</span><span class="source-lf">(</span><span class="source-lf constant-numeric-int-lflang">0</span><span class="source-lf">);</span>
<span class="source-lf">        });</span>
<span class="source-lf">    </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf">}</span>
<span class="source-lf"></span>
<span class="source-lf">    </span><span class="source-lf keyword-control-lflang">reaction</span><span class="source-lf">(a) {</span><span class="source-lf keyword-operator-lflang">=</span>
<span class="source-lf">        auto elapsed_time </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> get_elapsed_logical_time();</span>
<span class="source-lf">        </span><span class="source-lf variable-other-constant-reactorinstance-lflang">std</span><span class="source-lf keyword-operator-lflang">::</span><span class="source-lf variable-other-lflang">cout</span><span class="source-lf"> << </span><span class="source-lf string-quoted-double-lflang">"</span><span class="source-lf string-quoted-double-lflang">Asynchronous callback </span><span class="source-lf string-quoted-double-lflang">"</span><span class="source-lf"> << i</span><span class="source-lf keyword-operator-lflang">+</span><span class="source-lf keyword-operator-lflang">+</span><span class="source-lf"> << </span><span class="source-lf string-quoted-double-lflang">"</span><span class="source-lf string-quoted-double-lflang">: Assigned logical </span><span class="source-lf string-quoted-double-lflang">"</span>
<span class="source-lf">                  << </span><span class="source-lf string-quoted-double-lflang">"</span><span class="source-lf string-quoted-double-lflang">time greater than start time by </span><span class="source-lf string-quoted-double-lflang">"</span><span class="source-lf"> << elapsed_time << </span><span class="source-lf variable-other-constant-reactorinstance-lflang">std</span><span class="source-lf keyword-operator-lflang">::</span><span class="source-lf variable-other-lflang">endl</span><span class="source-lf">;</span>
<span class="source-lf">        if (elapsed_time <</span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> expected_time) {</span>
<span class="source-lf">            </span><span class="source-lf variable-other-constant-reactorinstance-lflang">std</span><span class="source-lf keyword-operator-lflang">::</span><span class="source-lf variable-other-lflang">cerr</span><span class="source-lf"> << </span><span class="source-lf string-quoted-double-lflang">"</span><span class="source-lf string-quoted-double-lflang">ERROR: Expected logical time to be larger than </span><span class="source-lf string-quoted-double-lflang">"</span>
<span class="source-lf">                      << expected_time << </span><span class="source-lf variable-other-constant-reactorinstance-lflang">std</span><span class="source-lf keyword-operator-lflang">::</span><span class="source-lf variable-other-lflang">endl</span><span class="source-lf">;</span>
<span class="source-lf">            exit(</span><span class="source-lf constant-numeric-int-lflang">1</span><span class="source-lf">);</span>
<span class="source-lf">        }</span>
<span class="source-lf">        if (toggle) {</span>
<span class="source-lf">            toggle </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf constant-language-lflang">false</span><span class="source-lf">;</span>
<span class="source-lf">            expected_time </span><span class="source-lf keyword-operator-lflang">+</span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> 200ms;</span>
<span class="source-lf">        } else {</span>
<span class="source-lf">            toggle </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf constant-language-lflang">true</span><span class="source-lf">;</span>
<span class="source-lf">        }</span>
<span class="source-lf">    </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf">}</span>
<span class="source-lf"></span>
<span class="source-lf">    </span><span class="source-lf keyword-control-lflang">reaction</span><span class="source-lf">(</span><span class="source-lf support-variable-lflang">shutdown</span><span class="source-lf">) {</span><span class="source-lf keyword-operator-lflang">=</span>
<span class="source-lf comment-line-double-dash-lflang">        </span><span class="source-lf comment-line-double-dash-lflang">// make sure to join the thread before shutting down</span>
<span class="source-lf">        if(</span><span class="source-lf variable-other-constant-reactorinstance-lflang">thread</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">joinable</span><span class="source-lf">()) {</span>
<span class="source-lf">            </span><span class="source-lf variable-other-constant-reactorinstance-lflang">thread</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">join</span><span class="source-lf">();</span>
<span class="source-lf">        }</span>
<span class="source-lf">    </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf">}</span>
<span class="source-lf">}</span>
<span class="source-lf"></span>
