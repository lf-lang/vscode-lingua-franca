<span class="source-lf comment-line-double-dash-lflang">// Test asynchronous callbacks that trigger a physical action.</span>
<span class="source-lf meta-targetspec-lflang keyword-control-lflang">target</span><span class="source-lf meta-targetspec-lflang"> </span><span class="source-lf meta-targetspec-lflang constant-language-lflang">Rust</span><span class="source-lf meta-targetspec-lflang"> {</span>
<span class="source-lf meta-targetspec-lflang variable-parameter-lflang">    timeout</span><span class="source-lf meta-targetspec-lflang">: </span><span class="source-lf meta-targetspec-lflang constant-numeric-int-lflang">1000</span><span class="source-lf meta-targetspec-lflang"> ms,</span>
<span class="source-lf meta-targetspec-lflang variable-parameter-lflang">    cargo-features</span><span class="source-lf meta-targetspec-lflang">: [</span><span class="source-lf meta-targetspec-lflang string-quoted-double-lflang">"</span><span class="source-lf meta-targetspec-lflang string-quoted-double-lflang">cli</span><span class="source-lf meta-targetspec-lflang string-quoted-double-lflang">"</span><span class="source-lf meta-targetspec-lflang">]</span>
<span class="source-lf meta-targetspec-lflang">}</span>
<span class="source-lf"></span>
<span class="source-lf storage-modifier-lflang">main</span><span class="source-lf"> </span><span class="source-lf storage-modifier-lflang">reactor</span><span class="source-lf"> </span><span class="source-lf entity-name-type-lflang">AsyncCallback</span><span class="source-lf">(period:</span><span class="source-lf storage-type-lflang"> time</span><span class="source-lf">(</span><span class="source-lf constant-numeric-int-lflang">10</span><span class="source-lf"> </span><span class="source-lf constant-numeric-lflang">msec</span><span class="source-lf">)) {</span>
<span class="source-lf">    </span><span class="source-lf keyword-control-lflang">preamble</span><span class="source-lf"> {</span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> use </span><span class="source-lf variable-other-constant-reactorinstance-lflang">std</span><span class="source-lf keyword-operator-lflang">::</span><span class="source-lf variable-other-lflang">thread</span><span class="source-lf">; </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf">}</span>
<span class="source-lf"></span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">timer</span><span class="source-lf"> t(</span><span class="source-lf constant-numeric-int-lflang">0</span><span class="source-lf">, period)</span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">state</span><span class="source-lf"> thread:</span><span class="source-lf entity-name-type-lflang"> Option</span><span class="source-lf"><</span><span class="source-lf variable-other-constant-reactorinstance-lflang">thread</span><span class="source-lf keyword-operator-lflang">::</span><span class="source-lf variable-other-lflang">JoinHandle</span><span class="source-lf"><unit>></span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">state</span><span class="source-lf"> expected_time:</span><span class="source-lf storage-type-lflang"> time</span><span class="source-lf">(period)</span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">state</span><span class="source-lf"> period:</span><span class="source-lf storage-type-lflang"> time</span><span class="source-lf">(period)</span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">state</span><span class="source-lf"> toggle:</span><span class="source-lf storage-type-lflang"> bool</span><span class="source-lf">(</span><span class="source-lf constant-language-lflang">false</span><span class="source-lf">)</span>
<span class="source-lf"></span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">physical</span><span class="source-lf"> </span><span class="source-lf storage-modifier-lflang">action</span><span class="source-lf"> act</span>
<span class="source-lf">    </span><span class="source-lf storage-modifier-lflang">state</span><span class="source-lf"> i:</span><span class="source-lf storage-type-lflang"> u32</span><span class="source-lf">(</span><span class="source-lf constant-numeric-int-lflang">0</span><span class="source-lf">)</span>
<span class="source-lf"></span>
<span class="source-lf">    </span><span class="source-lf keyword-control-lflang">reaction</span><span class="source-lf">(t) </span><span class="source-lf keyword-operator-lflang">-></span><span class="source-lf"> act {</span><span class="source-lf keyword-operator-lflang">=</span>
<span class="source-lf">        let act </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf variable-other-constant-reactorinstance-lflang">act</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">clone</span><span class="source-lf">();</span>
<span class="source-lf">        let period </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">period</span><span class="source-lf">;</span>
<span class="source-lf">        if let Some(old_thread) </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-constant-reactorinstance-lflang">thread</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">take</span><span class="source-lf">() {</span>
<span class="source-lf">            </span><span class="source-lf variable-other-constant-reactorinstance-lflang">old_thread</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">join</span><span class="source-lf">()</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf">ok();</span>
<span class="source-lf">        }</span>
<span class="source-lf comment-line-double-dash-lflang">        </span><span class="source-lf comment-line-double-dash-lflang">// start new thread</span>
<span class="source-lf">        let new_thread </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf variable-other-constant-reactorinstance-lflang">ctx</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">spawn_physical_thread</span><span class="source-lf">(move |ctx| {</span>
<span class="source-lf comment-line-double-dash-lflang">            </span><span class="source-lf comment-line-double-dash-lflang">// Simulate time passing before a callback occurs</span>
<span class="source-lf">            </span><span class="source-lf variable-other-constant-reactorinstance-lflang">thread</span><span class="source-lf keyword-operator-lflang">::</span><span class="source-lf variable-other-lflang">sleep</span><span class="source-lf">(period);</span>
<span class="source-lf comment-line-double-dash-lflang">            </span><span class="source-lf comment-line-double-dash-lflang">// Schedule twice. If the action is not physical, these should</span>
<span class="source-lf comment-line-double-dash-lflang">            </span><span class="source-lf comment-line-double-dash-lflang">// get consolidated into a single action triggering. If it is,</span>
<span class="source-lf comment-line-double-dash-lflang">            </span><span class="source-lf comment-line-double-dash-lflang">// then they cause two separate triggerings with close but not</span>
<span class="source-lf comment-line-double-dash-lflang">            </span><span class="source-lf comment-line-double-dash-lflang">// equal time stamps.</span>
<span class="source-lf">            </span><span class="source-lf variable-other-constant-reactorinstance-lflang">ctx</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">schedule_physical</span><span class="source-lf">(&act, Asap)</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf">ok();</span>
<span class="source-lf">            </span><span class="source-lf variable-other-constant-reactorinstance-lflang">ctx</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">schedule_physical</span><span class="source-lf">(&act, Asap)</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf">ok();</span>
<span class="source-lf">        });</span>
<span class="source-lf"></span>
<span class="source-lf">        </span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-constant-reactorinstance-lflang">thread</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">replace</span><span class="source-lf">(new_thread);</span>
<span class="source-lf">    </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf">}</span>
<span class="source-lf"></span>
<span class="source-lf">    </span><span class="source-lf keyword-control-lflang">reaction</span><span class="source-lf">(act) {</span><span class="source-lf keyword-operator-lflang">=</span>
<span class="source-lf">        let elapsed_time </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf variable-other-constant-reactorinstance-lflang">ctx</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">get_elapsed_logical_time</span><span class="source-lf">();</span>
<span class="source-lf">        let i </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">i</span><span class="source-lf">;</span>
<span class="source-lf">        println!(</span><span class="source-lf string-quoted-double-lflang">"</span><span class="source-lf string-quoted-double-lflang">Asynchronous callback {}: Assigned logical time greater than start time by {} ms</span><span class="source-lf string-quoted-double-lflang">"</span><span class="source-lf">,</span>
<span class="source-lf">                 i, </span><span class="source-lf variable-other-constant-reactorinstance-lflang">elapsed_time</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">as_millis</span><span class="source-lf">());</span>
<span class="source-lf">        assert!(elapsed_time > </span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">expected_time</span><span class="source-lf">,</span><span class="source-lf string-quoted-double-lflang">"</span><span class="source-lf string-quoted-double-lflang">ERROR: Expected logical time to be larger than {} ms</span><span class="source-lf string-quoted-double-lflang">"</span><span class="source-lf">, </span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-constant-reactorinstance-lflang">expected_time</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">as_millis</span><span class="source-lf">());</span>
<span class="source-lf"></span>
<span class="source-lf">        </span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">i</span><span class="source-lf"> </span><span class="source-lf keyword-operator-lflang">+</span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf constant-numeric-int-lflang">1</span><span class="source-lf">;</span>
<span class="source-lf">        if </span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">toggle</span><span class="source-lf"> {</span>
<span class="source-lf">            </span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">expected_time</span><span class="source-lf"> </span><span class="source-lf keyword-operator-lflang">+</span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">period</span><span class="source-lf">;</span>
<span class="source-lf">        }</span>
<span class="source-lf">        </span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">toggle</span><span class="source-lf"> </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> !</span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">toggle</span><span class="source-lf">;</span>
<span class="source-lf">    </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf">}</span>
<span class="source-lf"></span>
<span class="source-lf">    </span><span class="source-lf keyword-control-lflang">reaction</span><span class="source-lf">(</span><span class="source-lf support-variable-lflang">shutdown</span><span class="source-lf">) {</span><span class="source-lf keyword-operator-lflang">=</span>
<span class="source-lf">        if let Some(thread) </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf"> </span><span class="source-lf variable-other-constant-reactorinstance-lflang">self</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-constant-reactorinstance-lflang">thread</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">take</span><span class="source-lf">() {</span>
<span class="source-lf">            </span><span class="source-lf variable-other-constant-reactorinstance-lflang">thread</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf variable-other-lflang">join</span><span class="source-lf">()</span><span class="source-lf keyword-operator-lflang">.</span><span class="source-lf">ok();</span>
<span class="source-lf">        }</span>
<span class="source-lf">        println!(</span><span class="source-lf string-quoted-double-lflang">"</span><span class="source-lf string-quoted-double-lflang">success</span><span class="source-lf string-quoted-double-lflang">"</span><span class="source-lf">);</span>
<span class="source-lf">    </span><span class="source-lf keyword-operator-lflang">=</span><span class="source-lf">}</span>
<span class="source-lf">}</span>
<span class="source-lf"></span>
